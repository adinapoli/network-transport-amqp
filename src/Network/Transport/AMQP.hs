{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
{--|
  A Network Transport Layer for `distributed-process`
  based on AMQP and single-owner queues
--}

module Network.Transport.AMQP (
    createTransport
  , AMQPTransport(..)
  ) where

import qualified Network.AMQP as AMQP
import qualified Data.Text as T
import Data.UUID.V4
import Data.UUID (toString)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import GHC.Generics (Generic)
import Data.ByteString (ByteString)
import qualified Data.ByteString.Lazy as BL
import Data.String.Conv
import Data.Serialize
import Data.Monoid
import Network.Transport
import Network.Transport.Internal (asyncWhenCancelled)
import Control.Concurrent.MVar
import Control.Applicative
import Control.Monad
import Control.Exception
import Control.Concurrent.Chan (Chan, newChan, readChan, writeChan)

import Lens.Family2
import Lens.Family2.TH

--------------------------------------------------------------------------------
data AMQPTransport = AMQPTransport {
    transportConnection :: AMQP.Connection
  , transportChannel :: AMQP.Channel
  , transportEndpoint :: !(Maybe T.Text)
    -- ^ The queue and exchange name. If not specified, will be randomised.
  }

--------------------------------------------------------------------------------
-- | Largely inspired to: `network-transport-zeromq` by Tweag I/O.
data AMQPMessage
  = MessageConnect !EndPointAddress -- ^ Connection greeting
  | MessageInitConnection !EndPointAddress !ConnectionId !Reliability
  | MessageInitConnectionOk !EndPointAddress !ConnectionId !ConnectionId
  | MessageCloseConnection !ConnectionId
  | MessageData !ConnectionId ![ByteString]
  | MessageEndPointClose !EndPointAddress !Bool
  | MessageEndPointCloseOk !EndPointAddress
  deriving (Show, Generic)

deriving instance Generic EndPointAddress
instance Serialize EndPointAddress
deriving instance Generic Reliability
instance Serialize Reliability
instance Serialize AMQPMessage

--------------------------------------------------------------------------------
-- | Data created by the `Transport` during bootstrap. The rationale is that
-- we need to emulate point-to-point communication in RabbitMQ via a "direct"
-- exchange and a single ownership queue. We also want to ensure the exchange
-- gets deleted every time an `Endpoint` disconnects.
data AMQPContext = AMQPContext {
    ctx_evtChan :: !(Chan Event)
  , ctx_endpoint :: !T.Text 
  , ctx_state :: !(MVar LocalEndPointState)
  }

data LocalEndPointState =
    LocalEndPointValid !ValidLocalEndPointState
  | LocalEndPointClosed

data ValidLocalEndPointState = ValidLocalEndPointState
  { -- Remote `Endpoint` this machine "have seen"
    _nextConnectionId :: !ConnectionId
  , _localConnections :: !(Map ConnectionId EndPointAddress)
  }

makeLenses ''ValidLocalEndPointState


--------------------------------------------------------------------------------
encode' :: AMQPMessage -> BL.ByteString
encode' = encodeLazy

--------------------------------------------------------------------------------
decode' :: AMQP.Message -> Either String AMQPMessage
decode' = decodeLazy . AMQP.msgBody

--------------------------------------------------------------------------------
apiNewEndPoint :: AMQPTransport
               -> IO (Either (TransportError NewEndPointErrorCode) EndPoint)
apiNewEndPoint tr@AMQPTransport{..} = do
  try . asyncWhenCancelled closeEndPoint $ do
    uuid <- toS . toString <$> nextRandom
    (ourEndPoint,_,_) <- AMQP.declareQueue transportChannel $ AMQP.newQueue {
                           AMQP.queueName = maybe uuid toS transportEndpoint
                         , AMQP.queuePassive = False
                         , AMQP.queueDurable = False
                         , AMQP.queueExclusive = True
                         }
    -- TODO: Is this a bad idea? Reuse as exchange name the random queue
    -- generated by RabbitMQ
    let ourExchange = ourEndPoint
    ctx@AMQPContext{..} <- newAMQPCtx ourExchange
    AMQP.declareExchange transportChannel $ AMQP.newExchange {
        AMQP.exchangeName = ourExchange
      , AMQP.exchangeType = "direct"
      , AMQP.exchangePassive = False
      , AMQP.exchangeDurable = False
      , AMQP.exchangeAutoDelete = True
    }

    AMQP.bindQueue transportChannel ourEndPoint ourExchange mempty

    AMQP.consumeMsgs transportChannel ourEndPoint AMQP.NoAck $ \(msg,env) -> do
      case decode' msg of
        Left _ -> return ()
        Right (MessageInitConnection ep cId rel) -> do
          writeChan ctx_evtChan $ ConnectionOpened cId rel ep
          print "MessageInitConnection"
          -- TODO: Change me, sending twice 'cId'
          --publish transportChannel ep (MessageInitConnectionOk ep cId cId)
        Right (MessageData cId msg) -> do
          writeChan ctx_evtChan $ Received cId msg
          print "message data"
        rst -> print rst

    return EndPoint
      { receive       = readChan ctx_evtChan
      , address       = EndPointAddress $ toS ourEndPoint
      , connect       = apiConnect tr ctx
      , closeEndPoint = let evs = [ EndPointClosed
                                  , throw $ userError "Endpoint closed"
                                  ] in
                        apiCloseEndPoint tr ctx evs ourEndPoint
      , newMulticastGroup     = return . Left $ newMulticastGroupError
      , resolveMulticastGroup = return . Left . const resolveMulticastGroupError
      }
  where
    newMulticastGroupError =
      TransportError NewMulticastGroupUnsupported "Multicast not supported"
    resolveMulticastGroupError =
      TransportError ResolveMulticastGroupUnsupported "Multicast not supported"

--------------------------------------------------------------------------------
newAMQPCtx :: T.Text -> IO AMQPContext
newAMQPCtx ep = do
  ch <- newChan
  st <- newMVar emptyState
  return $ AMQPContext ch ep st
  where
    emptyState :: LocalEndPointState
    emptyState = LocalEndPointValid $ ValidLocalEndPointState 0 Map.empty

--------------------------------------------------------------------------------
apiCloseEndPoint :: AMQPTransport -> AMQPContext -> [Event] -> T.Text -> IO ()
apiCloseEndPoint AMQPTransport{..} AMQPContext{..} evts _ = do
  forM_ evts (writeChan ctx_evtChan)
  _ <- AMQP.deleteQueue transportChannel ctx_endpoint
  AMQP.deleteExchange transportChannel ctx_endpoint

--------------------------------------------------------------------------------
-- | Connnect to a remote `Endpoint`. What this means in the context of RabbitMQ
-- is that we are given the Exchange we need to publish to. To be sure the
-- Exchange do exist, we force its creation. The `declareExchange` command is
-- idempontent in Network.AMQP.
-- We certainly want to store the information that this `Endpoint` wanted to
-- communicate with the remote one.
apiConnect :: AMQPTransport
           -> AMQPContext
           -> EndPointAddress  -- ^ Remote address
           -> Reliability      -- ^ Reliability (ignored)
           -> ConnectHints     -- ^ Hints
           -> IO (Either (TransportError ConnectErrorCode) Connection)
apiConnect tr@AMQPTransport{..} ctx@AMQPContext{..} theirAddress reliability _ = do
  let ourAddress = EndPointAddress . toS $ ctx_endpoint
  try . asyncWhenCancelled close $ do
    if ourAddress == theirAddress
      then connectToSelf ctx
    else do
      mbConnId <- newConnectionTo ctx theirAddress
      print mbConnId
      -- A `Connection` specifies:
      -- 1. How I intend to communicate with this remote host
      -- 2. How can I shutdown the connection with it.
      case mbConnId of
        Nothing -> throwIO $ userError "apiConnect: LocalEndPointClosed"
        Just cid -> do
          writeChan ctx_evtChan (ConnectionOpened cid ReliableOrdered theirAddress)
          -- Say hello
          let msg = MessageInitConnection ourAddress cid reliability
          publish transportChannel theirAddress msg
          return Connection {
                      send = apiSend tr ctx theirAddress cid
                    , close = apiClose tr ctx theirAddress cid
                    }

--------------------------------------------------------------------------------
newConnectionTo :: AMQPContext -> EndPointAddress -> IO (Maybe ConnectionId)
newConnectionTo AMQPContext{..} theirAddress =
  modifyMVar ctx_state $ \st -> case st of
    LocalEndPointValid s -> do
        let cId = s ^. nextConnectionId
        let ns  = over localConnections (Map.insert cId theirAddress) s
        return (LocalEndPointValid (over nextConnectionId (+1) ns), Just cId)
    LocalEndPointClosed -> return (LocalEndPointClosed, Nothing)

--------------------------------------------------------------------------------
connectFailed :: SomeException -> TransportError ConnectErrorCode
connectFailed = TransportError ConnectFailed . show

--------------------------------------------------------------------------------
connectToSelf :: AMQPContext -> IO Connection
connectToSelf ctx@AMQPContext{..} = do
    let ep = EndPointAddress . toS $ ctx_endpoint
    mbConnId  <- newConnectionTo ctx ep
    case mbConnId of
      Nothing -> throwIO $ TransportError ConnectFailed "Connection Failed"
      Just cId -> do
        writeChan ctx_evtChan $ ConnectionOpened cId ReliableOrdered ep
        return Connection { 
            send  = selfSend cId
          , close = selfClose cId
        }
  where
    selfSend :: ConnectionId
             -> [ByteString]
             -> IO (Either (TransportError SendErrorCode) ())
    selfSend connId msg =
      try . withMVar ctx_state $ \st -> case st of
        LocalEndPointValid _ -> do
            writeChan ctx_evtChan (Received connId msg)
        LocalEndPointClosed ->
          throwIO $ TransportError SendFailed "Endpoint closed"

    selfClose :: ConnectionId -> IO ()
    selfClose connId =
      modifyMVar_ ctx_state $ \st -> case st of
        LocalEndPointValid _ -> do
          writeChan ctx_evtChan (ConnectionClosed connId)
          return LocalEndPointClosed
        LocalEndPointClosed -> return LocalEndPointClosed

--------------------------------------------------------------------------------
publish :: AMQP.Channel 
        -> EndPointAddress 
        -> AMQPMessage 
        -> IO ()
publish transportChannel address msg = do
    AMQP.publishMsg transportChannel
                    (toS . endPointAddressToByteString $ address)
                    mempty
                    (AMQP.newMsg { AMQP.msgBody = encode' $ msg
                                 , AMQP.msgDeliveryMode = Just AMQP.NonPersistent
                                 })

--------------------------------------------------------------------------------
-- TODO: Deal with exceptions and error at the broker level.
apiSend :: AMQPTransport
        -> AMQPContext
        -> EndPointAddress
        -> ConnectionId
        -> [ByteString] -> IO (Either (TransportError SendErrorCode) ())
apiSend AMQPTransport{..} AMQPContext{..} their connId msgs = Right <$>
  publish transportChannel their (MessageData connId msgs)

--------------------------------------------------------------------------------
-- | Change the status of this `Endpoint` to be closed
apiClose :: AMQPTransport
         -> AMQPContext
         -> EndPointAddress
         -> ConnectionId
         -> IO ()
apiClose _ AMQPContext{..} _ connId = do
  print "api close"
  modifyMVar_ ctx_state $ return . const LocalEndPointClosed
  writeChan ctx_evtChan (ConnectionClosed connId)

--------------------------------------------------------------------------------
createTransport :: AMQPTransport -> Transport
createTransport transport = Transport {
    newEndPoint = apiNewEndPoint transport
  , closeTransport = AMQP.closeConnection . transportConnection $ transport
  }

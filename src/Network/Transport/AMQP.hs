{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{--|
  A Network Transport Layer for `distributed-process`
  based on AMQP and single-owner queues
--}

module Network.Transport.AMQP (
    createTransport
  , AMQPParameters(..)
  ) where

import Network.Transport.AMQP.Internal.Types

import qualified Network.AMQP as AMQP
import qualified Data.Text as T
import Data.UUID.V4
import Data.IORef
import Data.List (foldl1')
import Data.UUID (toString, toWords)
import Data.Bits
import qualified Data.Map.Strict as Map
import Data.ByteString (ByteString)
import Data.Foldable
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString as B
import Data.String.Conv
import Data.Serialize
import Network.Transport
import Network.Transport.Internal (asyncWhenCancelled)
import Control.Concurrent.MVar
import Control.Monad
import Control.Exception
import Control.Concurrent.Chan (Chan, newChan, readChan, writeChan)

import Lens.Family2

--------------------------------------------------------------------------------
-- Utility functions
--------------------------------------------------------------------------------

encode' :: AMQPMessage -> BL.ByteString
encode' = encodeLazy

--------------------------------------------------------------------------------
decode' :: AMQP.Message -> Either String AMQPMessage
decode' = decodeLazy . AMQP.msgBody

--------------------------------------------------------------------------------
apiNewEndPoint :: AMQPInternalState
               -> IO (Either (TransportError NewEndPointErrorCode) EndPoint)
apiNewEndPoint is@AMQPInternalState{..} = do
  try . asyncWhenCancelled closeEndPoint $ do
    let AMQPParameters{..} = istate_params
    modifyMVar istate_tstate $ \tst -> case tst of
      TransportClosed -> throwIO $ TransportError NewEndPointFailed "Transport is closed."
      TransportValid (ValidTransportState cnn oldMap) -> do
        newChannel <- AMQP.openChannel transportConnection
        uuid <- toS . toString <$> nextRandom
        (ourEndPoint,_,_) <- AMQP.declareQueue newChannel $ AMQP.newQueue {
                            AMQP.queueName = maybe uuid toS transportEndpoint
                            , AMQP.queuePassive = False
                            , AMQP.queueDurable = False
                            , AMQP.queueExclusive = True
                            }
        -- TODO: Is this a bad idea? Reuse as exchange name the random queue
        -- generated by RabbitMQ
        let ourExchange = ourEndPoint
        (ourLocalEp, es@ValidLocalEndPointState{..}) <- newLocalEndPoint (toAddress ourEndPoint) newChannel

        let newMap = Map.insert (toAddress ourEndPoint) ourLocalEp oldMap

        AMQP.declareExchange newChannel $ AMQP.newExchange {
              AMQP.exchangeName = ourExchange
            , AMQP.exchangeType = "direct"
            , AMQP.exchangePassive = False
            , AMQP.exchangeDurable = False
            , AMQP.exchangeAutoDelete = True
            }

        AMQP.bindQueue newChannel ourEndPoint ourExchange mempty

        startReceiver is ourLocalEp

        let newEp =  EndPoint {
              receive       = readChan _localChan
            , address       = EndPointAddress $ toS ourEndPoint
            , connect       = apiConnect is ourLocalEp
            , closeEndPoint = apiCloseEndPoint is ourLocalEp
            , newMulticastGroup     = return . Left $ newMulticastGroupError
            , resolveMulticastGroup = return . Left . const resolveMulticastGroupError
            }
        return (TransportValid (ValidTransportState cnn newMap), newEp)
  where
    newMulticastGroupError =
      TransportError NewMulticastGroupUnsupported "Multicast not supported"
    resolveMulticastGroupError =
      TransportError ResolveMulticastGroupUnsupported "Multicast not supported"

--------------------------------------------------------------------------------
startReceiver :: AMQPInternalState -> LocalEndPoint -> IO ()
startReceiver tr@AMQPInternalState{..} lep@LocalEndPoint{..} = do
  -- TODO: Catch the exception thrown when the _localChannel will be shutdown.
  old <- readMVar localState
  case old of
    LocalEndPointValid ValidLocalEndPointState{..} -> do
      void $ AMQP.consumeMsgs _localChannel (fromAddress localAddress) AMQP.NoAck $ \(msg,_) -> do
        case decode' msg of
          Left _ -> return ()
          Right v@(MessageInitConnection theirAddr theirId rel) -> do
              print v
              (rep, isNew) <- getOrCreateRemoteEndPoint lep theirAddr
              print $ "Inside MessageInitConn: isNew " ++ show isNew
              when isNew $ do
                  ourId <- newConnectionTo lep rep
                  publish _localChannel theirAddr (MessageInitConnectionOk localAddress ourId theirId)
              -- TODO: This is a bug?. I need to issue a ConnectionOpened with the
              -- internal counter I am keeping, not the one coming from the remote
              -- endpoint.
              writeChan _localChan $ ConnectionOpened theirId rel theirAddr
          Right v@(MessageData cId rawMsg) -> do
              print v
              writeChan _localChan $ Received cId rawMsg
          Right v@(MessageInitConnectionOk theirAddr theirId ourId) -> do
              print v
              writeChan _localChan $ ConnectionOpened theirId ReliableOrdered theirAddr
          Right v@(MessageCloseConnection theirAddr theirId) -> do
              print v
              dead <- closeRemoteConnection tr lep theirAddr theirId
              print $ "Message Close connection - dead: " ++ show dead
              writeChan _localChan $ ConnectionClosed theirId
              print $ "MessageCloseConnection: after writeChan"
          Right v@(MessageEndPointClose theirAddr theirId) -> do
              print v
              unless (localAddress == theirAddr) $ do
                  void $ closeRemoteConnection tr lep theirAddr theirId
                  writeChan _localChan $ ConnectionClosed theirId
          rst -> print rst
    _ -> return ()


--------------------------------------------------------------------------------
withValidLocalState_ :: LocalEndPoint
                     -> (ValidLocalEndPointState -> IO ())
                     -> IO ()
withValidLocalState_ LocalEndPoint{..} f = withMVar localState $ \st ->
  case st of
    LocalEndPointClosed -> return ()
    LocalEndPointNoAcceptConections -> return ()
    LocalEndPointValid v -> f v

--------------------------------------------------------------------------------
newLocalEndPoint :: EndPointAddress -> AMQP.Channel -> IO (LocalEndPoint, ValidLocalEndPointState)
newLocalEndPoint ep amqpCh = do
  ch <- newChan
  let newState = emptyState ch
  st <- newMVar (LocalEndPointValid newState)
  return (LocalEndPoint ep st, newState)
  where
    emptyState :: Chan Event -> ValidLocalEndPointState
    emptyState ch = ValidLocalEndPointState ch amqpCh 0 Map.empty Map.empty

--------------------------------------------------------------------------------
apiCloseEndPoint :: AMQPInternalState
                 -> LocalEndPoint
                 -> IO ()
apiCloseEndPoint AMQPInternalState{..} LocalEndPoint{..} = do
  let ourAddress = localAddress

  -- Notify all the remoters this EndPoint is dying.
  old <- readMVar localState
  case old of
    LocalEndPointClosed -> return ()
    LocalEndPointNoAcceptConections -> return ()
    LocalEndPointValid vst@ValidLocalEndPointState{..} -> do
      print (Map.keys $ vst ^. localConnections)
      forM_ (Map.toList $ vst ^. localConnections) $ \(theirId, RemoteEndPoint{..}) -> do
        withMVar remoteState $ \rst -> case rst of
          RemoteEndPointClosed -> return ()
          _ -> publish _localChannel remoteAddress (MessageEndPointClose ourAddress theirId)

      -- Close the given connection
      writeChan _localChan EndPointClosed
      let queue = fromAddress localAddress
      _ <- AMQP.deleteQueue _localChannel queue
      AMQP.closeChannel _localChannel

  void $ swapMVar localState LocalEndPointClosed

  modifyMVar_ istate_tstate $ \tst -> case tst of
    TransportClosed  -> return TransportClosed
    TransportValid v@ValidTransportState{..} -> do
       let newMap = Map.delete localAddress tstateEndPoints
       return (TransportValid v { tstateEndPoints = newMap })

--------------------------------------------------------------------------------
-- | Returns whether or not the `RemoteEndPoint` is now closed
closeRemoteConnection :: AMQPInternalState
                      -> LocalEndPoint
                      -> EndPointAddress
                      -> ConnectionId
                      -> IO Bool
closeRemoteConnection AMQPInternalState{..} LocalEndPoint{..} theirAddress connId = do
  print "Inside closeRemoteConnection"
  modifyMVar localState $ \lst -> case lst of
    (LocalEndPointValid vst@ValidLocalEndPointState{..}) -> do
      case Map.lookup connId (vst ^. localConnections) of
        Nothing -> throwIO $ InvariantViolated (EndPointNotInRemoteMap theirAddress)
        Just rep -> do
          clsd <- modifyMVar (remoteState rep) $ \rst -> case rst of
            RemoteEndPointValid v -> do
              let v' = decreaseConnections v
              print $ "Outgoing counter: " ++ show (_remoteOutgoingCount v')
              if (_remoteOutgoingCount v') <= 0
                then return (RemoteEndPointClosed, True)
                else return (RemoteEndPointValid v', False)
            RemoteEndPointClosed -> return (RemoteEndPointClosed, True)
          return (LocalEndPointValid vst, clsd)
    v -> return (v, True)
  where
    decreaseConnections :: ValidRemoteEndPointState -> ValidRemoteEndPointState
    decreaseConnections v@ValidRemoteEndPointState{..} = 
      v { _remoteOutgoingCount = _remoteOutgoingCount - 1 }

--------------------------------------------------------------------------------
toAddress :: T.Text -> EndPointAddress
toAddress = EndPointAddress . toS

--------------------------------------------------------------------------------
fromAddress :: EndPointAddress -> T.Text
fromAddress = toS . endPointAddressToByteString

--------------------------------------------------------------------------------
apiConnect :: AMQPInternalState
           -> LocalEndPoint
           -> EndPointAddress  -- ^ Remote address
           -> Reliability      -- ^ Reliability (ignored)
           -> ConnectHints     -- ^ Hints
           -> IO (Either (TransportError ConnectErrorCode) Connection)
apiConnect tr@AMQPInternalState{..} lep@LocalEndPoint{..} theirAddress reliability _ = do
  let ourAddress = localAddress
  try . asyncWhenCancelled close $ do
    lst <- takeMVar localState
    putMVar localState lst
    case lst of
      LocalEndPointClosed ->
        throwIO $ TransportError ConnectFailed "apiConnect: LocalEndPointClosed"
      LocalEndPointNoAcceptConections ->
        throw $ userError "apiConnect: local endpoint doesn't accept connections."
      LocalEndPointValid ValidLocalEndPointState{..} -> do
          (rep, isNew) <- getOrCreateRemoteEndPoint lep theirAddress
          newId <- newConnectionTo lep rep
          print $ "apiConnect cId: " ++ show newId
          print $ "apiConnect new: " ++ show isNew
          when isNew $ do
            let msg = MessageInitConnection ourAddress newId reliability
            publish _localChannel theirAddress msg
          return Connection {
                    send = apiSend tr lep theirAddress newId
                  , close = apiClose tr lep theirAddress newId
                 }

--------------------------------------------------------------------------------
newConnectionTo :: LocalEndPoint -> RemoteEndPoint -> IO ConnectionId
newConnectionTo LocalEndPoint{..} rep@RemoteEndPoint{..} = do
  modifyMVar localState $ \lst -> case lst of
    LocalEndPointClosed -> 
      throwIO $ TransportError ConnectFailed "newConnectionTo: LocalEndPointClosed"
    LocalEndPointNoAcceptConections ->
      throw $ userError "newConnectionTo: local endpoint doesn't accept connections."
    LocalEndPointValid v@ValidLocalEndPointState{..} -> do
      isAlive <- readIORef remoteAlive
      cId <- case isAlive of
        False -> throwIO $ TransportError ConnectFailed "newConnectionTo: RemoteEndPoint not alive"
        True -> modifyMVar remoteState $ \rst -> case rst of
          RemoteEndPointClosed ->
            throwIO $ TransportError ConnectFailed "newConnectionTo: RemoteEndPointClosed"
          RemoteEndPointValid v2@ValidRemoteEndPointState{..} -> do
            newId <- newConnectionId _localCounter remoteAddress
            let newRst = over remotePendingConnections (Map.insert newId localAddress) .
                         over remoteOutgoingCount (+1) $ v2
            return $ (RemoteEndPointValid newRst, newId)
      let newVs = over localConnections (Map.insert cId rep) .
                  over localCounter (+1) $ v
      return $ (LocalEndPointValid newVs, cId)

--------------------------------------------------------------------------------
-- | Find a remote endpoint. If the remote endpoint does not yet exist we
-- create it. Returns if the endpoint was new.
getOrCreateRemoteEndPoint :: LocalEndPoint
                          -> EndPointAddress
                          -> IO (RemoteEndPoint, Bool)
getOrCreateRemoteEndPoint lep@LocalEndPoint{..} theirAddr = 
  modifyMVar localState $ \lst -> case lst of
    LocalEndPointClosed -> 
      throwIO $ TransportError ConnectFailed "findRemoteEndPoint: LocalEndPointClosed"
    LocalEndPointNoAcceptConections ->
      throw $ userError "findRemoteEndpoint: local endpoint doesn't accept connections."
    LocalEndPointValid v ->
      case Map.lookup theirAddr (v ^. localRemotes) of
          -- TODO: Check if the RemoteEndPoint is closed.
          Just r -> return (LocalEndPointValid v, (r, False))
          Nothing -> do
            newRem <- newValidRemoteEndpoint lep theirAddr
            let newMap = Map.insert theirAddr newRem
            return (LocalEndPointValid $ over localRemotes newMap v, (newRem, True))

--------------------------------------------------------------------------------
addPendingConnection :: RemoteEndPoint -> EndPointAddress -> IO ()
addPendingConnection RemoteEndPoint{..} ep = modifyMVar_ remoteState $ \rst -> case rst of
  RemoteEndPointValid vst@ValidRemoteEndPointState{..} -> do
    newId <- newConnectionId _remoteOutgoingCount ep
    return $ RemoteEndPointValid vst
  v -> return v

--------------------------------------------------------------------------------
newValidRemoteEndpoint :: LocalEndPoint
                       -> EndPointAddress
                       -> IO RemoteEndPoint
newValidRemoteEndpoint LocalEndPoint{..} ep = do
  let st = newValidRemoteState
  var <- newMVar $ RemoteEndPointValid st
  alive <- newIORef True
  return $ RemoteEndPoint ep var alive
  where
    newValidRemoteState :: ValidRemoteEndPointState
    newValidRemoteState = ValidRemoteEndPointState Map.empty 0

--------------------------------------------------------------------------------
newConnectionId :: Int -> EndPointAddress -> IO ConnectionId
newConnectionId counter ep = do
  let queueAsWord64 = foldl1' (+) (map fromIntegral $ B.unpack . endPointAddressToByteString $ ep)
  (a,b,c,d) <- toWords <$> nextRandom
  return $ fromIntegral (a .|. b .|. c .|. d) + queueAsWord64 + fromIntegral counter

-- --------------------------------------------------------------------------------
-- -- TODO: Deal with exceptions.
-- connectToSelf :: LocalEndPoint -> IO Connection
-- connectToSelf lep@LocalEndPoint{..} = do
--     let ourEndPoint = localAddress
--     (rep, _) <- getOremoteEndPoint lep ourEndPoint
--     let cId = remoteId rep
--     withValidLocalState_ lep $ \ValidLocalEndPointState{..} ->
--       writeChan _localChan $ ConnectionOpened cId ReliableOrdered ourEndPoint
--     return Connection { 
--         send  = selfSend cId
--       , close = selfClose cId
--     }
--   where
--     selfSend :: ConnectionId
--              -> [ByteString]
--              -> IO (Either (TransportError SendErrorCode) ())
--     selfSend connId msg =
--       try . withMVar localState $ \st -> case st of
--         LocalEndPointValid ValidLocalEndPointState{..} -> do
--             writeChan _localChan (Received connId msg)
--         LocalEndPointNoAcceptConections -> do
--           throwIO $ TransportError SendClosed "selfSend: Connections no more."
--         LocalEndPointClosed ->
--           throwIO $ TransportError SendFailed "selfSend: Connection closed"
-- 
--     selfClose :: ConnectionId -> IO ()
--     selfClose connId = do
--       modifyMVar_ localState $ \st -> case st of
--         LocalEndPointValid ValidLocalEndPointState{..} -> do
--           writeChan _localChan (ConnectionClosed connId)
--           return LocalEndPointNoAcceptConections
--         LocalEndPointNoAcceptConections ->
--           throwIO $ TransportError SendFailed "selfClose: No connections accepted"
--         LocalEndPointClosed -> 
--           throwIO $ TransportError SendClosed "selfClose: Connection closed"

--------------------------------------------------------------------------------
publish :: AMQP.Channel 
        -> EndPointAddress 
        -> AMQPMessage 
        -> IO ()
publish transportChannel address msg = do
    AMQP.publishMsg transportChannel
                    (toS . endPointAddressToByteString $ address)
                    mempty
                    (AMQP.newMsg { AMQP.msgBody = encode' msg
                                 , AMQP.msgDeliveryMode = Just AMQP.NonPersistent
                                 })

--------------------------------------------------------------------------------
-- TODO: Deal with exceptions and error at the broker level.
apiSend :: AMQPInternalState
        -> LocalEndPoint
        -> EndPointAddress
        -> ConnectionId
        -> [ByteString] -> IO (Either (TransportError SendErrorCode) ())
apiSend is LocalEndPoint{..} their connId msgs = do
  print "Inside apiSend"
  try . withMVar (istate_tstate is) $ \tst -> case tst of
    TransportClosed -> 
      throwIO $ TransportError SendFailed "apiSend: TransportClosed"
    TransportValid _ -> withMVar localState $ \lst -> case lst of
      (LocalEndPointValid vst@ValidLocalEndPointState{..}) -> case Map.lookup connId (vst ^. localConnections) of
        Nothing  -> throwIO $ TransportError SendFailed "apiSend: address not in local connections"
        Just rep -> withMVar (remoteState rep) $ \rst -> case rst of
          RemoteEndPointClosed -> throwIO $ TransportError SendFailed "apiSend: Connection closed"
          RemoteEndPointValid _ ->  publish _localChannel their (MessageData connId msgs)
      _ -> throwIO $ TransportError SendFailed "apiSend: LocalEndPointClosed"

--------------------------------------------------------------------------------
-- | Change the status of the `RemoteEndPoint` to be closed. If the
-- `EndPoint` is already closed, we simply return.
apiClose :: AMQPInternalState
         -> LocalEndPoint
         -> EndPointAddress
         -> ConnectionId
         -> IO ()
apiClose tr@AMQPInternalState{..} lep@LocalEndPoint{..} ep connId = do
  print "Inside API Close"
  let ourAddress = localAddress
  print "apiClose: after closeRemote"
  withValidLocalState_ lep $ \ValidLocalEndPointState{..} ->
    publish _localChannel ep (MessageCloseConnection ourAddress connId)
  print "apiClose: after publishing"

--------------------------------------------------------------------------------
createTransport :: AMQPParameters -> IO Transport
createTransport params@AMQPParameters{..} = do
  let validTState = ValidTransportState transportConnection Map.empty
  tState <- newMVar (TransportValid validTState)
  let iState = AMQPInternalState params tState
  return Transport {
    newEndPoint = apiNewEndPoint iState
  , closeTransport = apiCloseTransport iState
  }

--------------------------------------------------------------------------------
apiCloseTransport :: AMQPInternalState -> IO ()
apiCloseTransport is = do
  old <- readMVar $ istate_tstate is
  case old of
    TransportClosed -> return ()
    -- Do not close the externally-passed AMQP connection,
    -- or it will compromise users sharing it!
    TransportValid (ValidTransportState _ mp) -> traverse_ (apiCloseEndPoint is) mp
  void $ swapMVar (istate_tstate is) TransportClosed
